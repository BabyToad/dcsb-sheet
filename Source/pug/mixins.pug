//- Dark City, Shining Babel - Reusable Pug Mixins
//- Component library for the Runner Dossier sheet

//- ═══════════════════════════════════════════════════════════════
//- INPUT COMPONENTS
//- ═══════════════════════════════════════════════════════════════

//- Text input with floating label
mixin text-input(name, label, extraclass)
    label(class=["text-input", extraclass])&attributes(attributes)
        input(type="text", name=`attr_${name}`)
        if label
            .label(data-i18n=label)
                block

//- Number input with label
mixin number-input(name, label, extraclass)
    label(class=["number-input", extraclass])&attributes(attributes)
        input(type="number", name=`attr_${name}`)
        if label
            .label(data-i18n=label)
                block

//- Checkbox input
mixin checkbox(name, value, label)
    label.checkbox&attributes(attributes)
        input(type="checkbox", name=`attr_${name}`, value=value)
        span(data-i18n=label)

//- ═══════════════════════════════════════════════════════════════
//- ACTION & ATTRIBUTE COMPONENTS
//- ═══════════════════════════════════════════════════════════════

//- Action row with clickable name (fakeradio checkbox pattern)
//- Uses "inverse fill": all dots start filled, dots AFTER checked become empty
//- DOM order: 0,1,2,3,4 (normal) - CSS :checked ~ sibling unfills following dots
mixin action-row(name, label)
    .action-row
        button.action-name(type="action", name=`act_roll_${name}`, data-i18n=label)
        .action-dots
            //- Hidden zero-value checkbox (default state)
            input.fakeradio.zero(type="checkbox", name=`attr_${name}`, value="0", checked)
            //- Visible dots with incrementing values
            - for (var i = 1; i <= 4; i++)
                input.fakeradio(type="checkbox", name=`attr_${name}`, value=i, id=`${name}_${i}`)
                label.dot(for=`${name}_${i}`)

//- Attribute rating track (derived from highest action)
//- Uses same fakeradio inverse-fill pattern
mixin attribute-track(name)
    .attribute-track
        //- Hidden zero-value checkbox (default state)
        input.fakeradio.zero(type="checkbox", name=`attr_${name}_rating`, value="0", checked)
        //- Visible dots
        - for (var i = 1; i <= 4; i++)
            input.fakeradio(type="checkbox", name=`attr_${name}_rating`, value=i, id=`${name}_rating_${i}`)
            label.attr-dot(for=`${name}_rating_${i}`)

//- XP track (6 or 8 boxes)
mixin xp-track(name, count)
    .xp-boxes
        - for (var i = 1; i <= count; i++)
            input(type="checkbox", name=`attr_${name}_xp_${i}`, value="1", id=`${name}_xp_${i}`)
            label.xp-box(for=`${name}_xp_${i}`)

//- ═══════════════════════════════════════════════════════════════
//- TRACKER COMPONENTS
//- ═══════════════════════════════════════════════════════════════

//- Generic checkbox track (stress, trauma, rep, heat, etc.)
//- @param {string} name - Base attribute name (e.g., "stress", "rep")
//- @param {number} count - Number of boxes
//- @param {string} boxClass - CSS class for label boxes (e.g., "stress-box", "rep-box")
mixin checkbox-track(name, count, boxClass)
    - for (var i = 1; i <= count; i++)
        input(type="checkbox", name=`attr_${name}_${i}`, value="1", id=`${name}_${i}`)
        label(class=boxClass, for=`${name}_${i}`)

//- Fakeradio track with forward fill (clicking fills all boxes up to and including clicked)
//- Uses fakeradio pattern: boxes start filled, clicking empties boxes after selection
//- @param {string} name - Attribute name (stores the count as value)
//- @param {number} count - Number of boxes
//- @param {string} boxClass - CSS class for label boxes
mixin fakeradio-track(name, count, boxClass)
    //- Hidden zero-value checkbox (default state = nothing filled)
    input.fakeradio.zero(type="checkbox", name=`attr_${name}`, value="0", checked)
    //- Visible boxes with incrementing values
    - for (var i = 1; i <= count; i++)
        input.fakeradio(type="checkbox", name=`attr_${name}`, value=i, id=`${name}_${i}`)
        label(class=boxClass, for=`${name}_${i}`)

//- Clock segments (configurable size)
mixin clock(name, segments, label)
    .clock(data-segments=segments)
        if label
            span.clock-label(data-i18n=label)
        .clock-segments
            - for (var i = 1; i <= segments; i++)
                input(type="checkbox", name=`attr_${name}_${i}`, value="1", id=`${name}_seg_${i}`)
                label.segment(for=`${name}_seg_${i}`)

//- Heat Gauge (6-segment with forward fill pattern)
//- Uses fakeradio pattern - stores single value 0-6
mixin heat-gauge(name)
    .heat-gauge
        .gauge-header
            .gauge-label(data-i18n="HEAT_GAUGE") HEAT GAUGE
            .gauge-dice
                span.dice-label Disengage:
                span.dice-count(name=`attr_${name}_dice`) 6
                span d6
        .gauge-track
            +fakeradio-track(name, 6, "gauge-box")

//- ═══════════════════════════════════════════════════════════════
//- EQUIPMENT COMPONENTS
//- ═══════════════════════════════════════════════════════════════

//- Item checkbox with load value
mixin item-checkbox(name, label, load)
    label.item-checkbox
        input(type="checkbox", name=`attr_${name}`, value="1")
        span.item-box
        span.item-name= label
        span.item-load= load

//- ═══════════════════════════════════════════════════════════════
//- STRUCTURAL COMPONENTS
//- ═══════════════════════════════════════════════════════════════

//- Section header (collapsible, with stamp styling)
mixin sectionheader(name, label)
    .section-header
        input(type="checkbox", name=`attr_show_${name}`, value="1", checked)
        h2(data-i18n=label)
            block

//- Repeating section wrapper
mixin repeating(name)
    fieldset(class=`repeating_${name}`)
        block

//- ═══════════════════════════════════════════════════════════════
//- CREW COMPONENTS
//- ═══════════════════════════════════════════════════════════════

//- Faction status row
mixin faction-status(name)
    .faction-row
        input(type="text", name=`attr_${name}_faction`, placeholder="Faction name").faction-name
        .status-track
            - for (var i = -3; i <= 3; i++)
                input(type="radio", name=`attr_${name}_status`, value=i, checked=(i === 0), id=`${name}_status_${i}`)
                label.status-pip(for=`${name}_status_${i}`, data-value=i)
                    if i === -3
                        span W
                    else if i === 3
                        span A

//- Cohort block with edit/display modes
mixin cohort-block()
    .cohort-entry
        //- Header row (always visible)
        .cohort-header-row
            .display.cohort-header-display
                span.cohort-name-display(name="attr_cohort_name")
                span.cohort-type-display (
                span.cohort-type-value(name="attr_cohort_type")
                span.cohort-type-display )
            .edit.cohort-header-edit
                input(type="text", name="attr_cohort_name", placeholder="Cohort name").cohort-name-input
                select(name="attr_cohort_type").cohort-type-select
                    option(value="gang") Gang
                    option(value="expert") Expert
            //- Elite toggle (always visible)
            label.cohort-elite-label
                input(type="checkbox", name="attr_cohort_elite", value="1").cohort-elite-check
                span.elite-box
                span.elite-label ELITE

        //- Info section (display/edit modes)
        .display.cohort-info-display
            .info-row
                span.info-label Tags:
                span.info-value(name="attr_cohort_tags")
            .info-row
                span.info-label Edges:
                span.info-value(name="attr_cohort_edges")
            .info-row
                span.info-label Flaws:
                span.info-value(name="attr_cohort_flaws")
        .edit.cohort-info-edit
            +text-input("cohort_tags", "TAGS")
            +text-input("cohort_edges", "EDGES")
            +text-input("cohort_flaws", "FLAWS")

        //- Harm track (always visible) - simple radio buttons
        .cohort-harm
            span.harm-label Harm:
            .harm-track
                label.harm-option
                    input(type="radio", name="attr_cohort_harm", value="0", checked)
                    span.harm-text None
                label.harm-option
                    input(type="radio", name="attr_cohort_harm", value="1")
                    span.harm-text Weak
                label.harm-option
                    input(type="radio", name="attr_cohort_harm", value="2")
                    span.harm-text Impaired
                label.harm-option
                    input(type="radio", name="attr_cohort_harm", value="3")
                    span.harm-text Broken
                label.harm-option
                    input(type="radio", name="attr_cohort_harm", value="4")
                    span.harm-text Dead

        //- Roll button (always visible)
        button(type="action", name="act_cohortroll").cohort-roll-btn Roll

//- Upgrade checkbox (single level)
mixin upgrade-checkbox(name, label, cost)
    label.upgrade-checkbox
        input(type="checkbox", name=`attr_${name}`, value="1")
        span.upgrade-box
        span.upgrade-name= label
        if cost && cost > 1
            span.upgrade-cost= `(${cost})`

//- Multi-level upgrade (e.g., Rides [][] )
//- @param {string} baseName - Base attribute name (boxes get _1, _2, etc.)
//- @param {string} label - Display label
//- @param {number} levels - Number of checkboxes
//- @param {number} cost - Cost per level (shown if > 1)
mixin upgrade-multi(baseName, label, levels, cost)
    .upgrade-checkbox.upgrade-multi
        - for (var i = 1; i <= levels; i++)
            input(type="checkbox", name=`attr_${baseName}_${i}`, value="1", id=`${baseName}_${i}`)
            label.upgrade-box(for=`${baseName}_${i}`)
        span.upgrade-name= label
        if cost && cost > 1
            span.upgrade-cost= `(${cost})`

//- ═══════════════════════════════════════════════════════════════
//- SECTION EDIT TOGGLE
//- Per-section edit mode with pencil icon
//- ═══════════════════════════════════════════════════════════════

//- Section header with edit toggle
//- @param {string} name - Section identifier (e.g., "identity", "augment")
//- @param {string} stamp - Display text for section stamp
//- @param {string} number - Section number (e.g., "01", "02")
mixin section-header-editable(name, stamp, number)
    input.section-edit-toggle(type="checkbox", name=`attr_edit_${name}`, id=`edit_${name}`)
    .section-header
        .section-stamp= stamp
        .section-number-group
            .section-number= number
            label.section-edit-btn(for=`edit_${name}`, title="Edit this section") ✎

//- ═══════════════════════════════════════════════════════════════
//- EDIT/DISPLAY MODE COMPONENTS
//- These output both edit and display versions of fields
//- CSS toggles visibility based on section edit toggle state
//- ═══════════════════════════════════════════════════════════════

//- Text field with edit/display modes
//- Display: span showing value
//- Edit: text input with label
mixin text-field(name, label)
    .field-group&attributes(attributes)
        //- Display mode - read-only span
        span.display.field-value(name=`attr_${name}`)
        //- Edit mode - editable input
        .edit
            label.text-input
                input(type="text", name=`attr_${name}`)
                if label
                    .label(data-i18n=label)

//- Textarea with edit/display modes
//- Display: span showing value
//- Edit: textarea
mixin textarea-field(name, placeholder)
    .field-group&attributes(attributes)
        //- Display mode - read-only span (shows text content)
        span.display.field-value(name=`attr_${name}`)
        //- Edit mode - editable textarea
        textarea.edit(name=`attr_${name}`, placeholder=placeholder)
